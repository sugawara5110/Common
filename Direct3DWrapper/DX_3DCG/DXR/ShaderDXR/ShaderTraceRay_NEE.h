///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      ShaderTraceRay_NEE.hlsl                                          //
///////////////////////////////////////////////////////////////////////////////////////////////////////////

char* ShaderTraceRay_NEE =

///////////////////////G項/////////////////////////////////////////////////////////////////////
"float G(in float3 hitPosition, in float3 normal, in RayPayload payload)\n"
"{\n"
"    float3 lightVec = payload.hitPosition - hitPosition;\n"
"    float3 light_normal = payload.normal;\n"
"    float3 hitnormal = normal;\n"
"    float3 Lvec = normalize(lightVec);\n"
"    float cosine1 = saturate(dot(-Lvec, light_normal));\n"
"    float cosine2 = saturate(dot(Lvec, hitnormal));\n"
"    float distance = length(lightVec);\n"

"    float distAtten = (distance * distance);\n"
"    return cosine1 * cosine2 / distAtten;\n"
"}\n"

///////////////////////NEE/////////////////////////////////////////////////////////////////////
"RayPayload Nee(in uint RecursionCnt, in float3 hitPosition, in float3 normal)\n"
"{\n"
"    uint NumEmissive = numEmissive.x;\n"
"    uint emIndex = Rand_integer() % NumEmissive;\n"
"    float3 ePos = emissivePosition[emIndex].xyz;\n"

"    RayDesc ray;\n"
"    ray.Direction = RandomVector(float3(1.0f, 0.0f, 0.0f), 2.0f);\n"//全方向

"    RayPayload payload;\n"
"    payload.color = float3(0.0f, 0.0f, 0.0f);\n"
"    payload.hitPosition = ePos;\n"
"    payload.mNo = EMISSIVE | NEE;\n"//処理分岐用

/////光源から点をランダムで取得
"    traceRay(RecursionCnt, RAY_FLAG_CULL_FRONT_FACING_TRIANGLES, 1, 1, ray, payload);\n"

"    if(payload.hit){\n"
"       float3 lightVec = payload.hitPosition - hitPosition;\n"
"       ray.Direction = normalize(lightVec);\n"
"       payload.hitPosition = hitPosition;\n"
"       payload.mNo = EMISSIVE | NEE;\n"//処理分岐用
////////今の位置から取得した光源位置へ飛ばす
"       traceRay(RecursionCnt, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 1, 1, ray, payload);\n"
"    }\n"
"    return payload;\n"
"}\n"

///////////////////////光源へ光線を飛ばす, ヒットした場合明るさが加算//////////////////////////
"float3 EmissivePayloadCalculate_NEE(in uint RecursionCnt, in float3 hitPosition, \n"
"                                    in float3 difTexColor, in float3 speTexColor, in float3 normal, in float3 throughput)\n"
"{\n"
"    uint materialID = getMaterialID();\n"
"    MaterialCB mcb = material[materialID];\n"
"    float3 Diffuse = mcb.Diffuse.xyz * difTexColor;\n"
"    float3 Speculer = mcb.Speculer.xyz * speTexColor;\n"
//"    float3 Ambient = mcb.Ambient.xyz + GlobalAmbientColor.xyz;\n"
"    float shininess = mcb.shininess;\n"

"    uint mNo = mcb.materialNo;\n"
"    float3 ret = difTexColor;\n"//光源だった場合、映り込みがそのまま出る・・・あとで変更する

"    bool mf = materialIdent(mNo, EMISSIVE);\n"
"    if(!mf) {\n"//emissive以外

"       RayPayload payload;\n"
"       payload.hitPosition = hitPosition;\n"
"       payload.hit = false;\n"

"       RayDesc ray;\n"
"       float LightArea = LightArea_RandNum.x;\n"
"       ray.Direction = RandomVector(normal, LightArea);\n"

////////Nee
"       RayPayload neeP = Nee(RecursionCnt, hitPosition, normal);\n"

"       float g = G(hitPosition, normal, neeP);\n"

"       float3 Lvec = normalize(neeP.hitPosition - hitPosition);\n"

"       float3 difBRDF = DiffuseBRDF(Diffuse);\n"
"       float3 eyeVec = normalize(cameraPosition.xyz - hitPosition);\n"
"       float3 speBRDF = SpecularPhongBRDF(Speculer, normal, eyeVec, Lvec, shininess);\n"

"       float PDF = CosinePDF(normal, ray.Direction) * 0.05;\n"
"       if(PDF <= 0)PDF = 1.0f;\n"
"       ret = throughput * ((difBRDF + speBRDF) * g / PDF) * neeP.color;\n"

"       float cosine = abs(dot(normal, ray.Direction));\n"
"       payload.throughput = throughput * (difBRDF + speBRDF) * cosine / PDF;\n"

////////PathTracing
"       payload.mNo = EMISSIVE | NEE_PATHTRACER;\n"//処理分岐用

"       payload.hitPosition = hitPosition;\n"
"       payload.EmissiveIndex = 0;\n"

"       traceRay(RecursionCnt, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 1, 1, ray, payload);\n"

"       ret += payload.color;\n"
"    }\n"
"    return ret;\n"
"}\n";